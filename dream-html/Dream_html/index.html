<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dream_html (dream-html.Dream_html)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">dream-html</a> &#x00BB; Dream_html</nav><header class="odoc-preamble"><h1>Module <code><span>Dream_html</span></code></h1><p><code>dream-html</code> is a library of useful functionality needed for making robust and maintainable server-driven web applications using the Dream web framework.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#form-handling">Form handling</a></li><li><a href="#html-and-other-markup">HTML and other markup</a></li><li><a href="#dream-wrappers">Dream wrappers</a></li><li><a href="#conditional-requests">Conditional requests</a></li><li><a href="#type-safe-routing">Type-safe routing</a></li><li><a href="#dreamwork">Dreamwork</a></li><li><a href="#live-reload-support">Live reload support</a></li></ul></nav></div><div class="odoc-content"><h3 id="form-handling"><a href="#form-handling" class="anchor"></a>Form handling</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Form"><a href="#module-Form" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Form/index.html">Form</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Typed, extensible HTML form decoder with error reporting for form field validation failures. Powerful chained decoding functionality–the validation of one field can depend on the values of other decoded fields.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-form"><a href="#val-form" class="anchor"></a><code><span><span class="keyword">val</span> form : 
  <span><span><span class="type-var">'a</span> <a href="Form/index.html#type-t">Form.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?csrf</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Dream</span>.request <span class="arrow">&#45;&gt;</span></span>
  <span><span>[&gt; <span><span class="type-var">'a</span> <span class="xref-unresolved">Dream</span>.form_result</span> <span><span>| `Invalid</span> of <span><span>(string * string)</span> list</span></span> ]</span> <span class="xref-unresolved">Dream</span>.promise</span></span></code></div><div class="spec-doc"><p>Type-safe wrapper for <code>Dream.form</code>. Similarly to that, you can match on the result:</p><pre class="language-ocaml"><code>  type new_user = { name : string; email : string }
  let new_user =
    let open Dream_html.Form in
    let+ name = required string &quot;name&quot;
    and+ email = required string &quot;email&quot; in
    { name; email }

  (* POST /users *)
  let post_users req =
    match%lwt Dream_html.form new_user req with
    | `Ok { name; email } -&gt; (* ... *)
    | `Invalid errors -&gt; Dream.json ~code:422 ( (* ...render errors... *) )
    | _ -&gt; Dream.empty `Bad_Request</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.8.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-query"><a href="#val-query" class="anchor"></a><code><span><span class="keyword">val</span> query : 
  <span><span><span class="type-var">'a</span> <a href="Form/index.html#type-t">Form.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Dream</span>.request <span class="arrow">&#45;&gt;</span></span>
  <span>[&gt; <span>`Ok of <span class="type-var">'a</span></span> <span><span>| `Invalid</span> of <span><span>(string * string)</span> list</span></span> ]</span></span></code></div><div class="spec-doc"><p>Type-safe wrapper for <code>Dream.all_queries</code>. Can be used to decode the query parameters into a typed value.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.8.0</li></ul></div></div><h3 id="html-and-other-markup"><a href="#html-and-other-markup" class="anchor"></a>HTML and other markup</h3><p>Correct construction of markup with the help of type-safe helpers and combinators.</p><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../pure-html/Pure_html/index.html">Pure_html</a></span></code></summary><h3 id="core-types"><a href="#core-types" class="anchor"></a>Core types</h3><p>These are the types of the final values which get rendered.</p><div class="odoc-spec"><div class="spec type anchored" id="type-attr"><a href="#type-attr" class="anchor"></a><code><span><span class="keyword">type</span> attr</span><span> = string * string</span></code></div><div class="spec-doc"><p>E.g. <code>id=&quot;toast&quot;</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.11.0 reveal the type definition in the interface.</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-node"><a href="#type-node" class="anchor"></a><code><span><span class="keyword">type</span> node</span></code></div><div class="spec-doc"><p>Either a tag, a comment, or text data in the markup.</p></div></div><h3 id="output"><a href="#output" class="anchor"></a>Output</h3><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_xml"><a href="#val-to_xml" class="anchor"></a><code><span><span class="keyword">val</span> to_xml : <span><span class="optlabel">?header</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Same as <code>to_string</code> but render void tags as XML-style self-closing tags.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">header</span> <p>print the XML header string if <code>true</code>. This is to allow both use cases where the XML code is embedded inside HTML, and standalone XML documents. Default is <code>false</code>. Since 3.6.0.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_xml"><a href="#val-pp_xml" class="anchor"></a><code><span><span class="keyword">val</span> pp_xml : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?header</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <code>pp</code> but render void tags as XML-style self-closing tags.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">header</span> <p>print the XML header string if <code>true</code>. This is to allow both use cases where the XML code is embedded inside HTML, and standalone XML documents. Default is <code>false</code>. Since 3.6.0.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0.</li></ul></div></div><h3 id="constructing-nodes-and-attributes"><a href="#constructing-nodes-and-attributes" class="anchor"></a>Constructing nodes and attributes</h3><div class="odoc-spec"><div class="spec type anchored" id="type-to_attr"><a href="#type-to_attr" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a to_attr</span></span><span> = <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-attr">attr</a></span></code></div><div class="spec-doc"><p>Attributes can be created from typed values.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-string_attr"><a href="#type-string_attr" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a string_attr</span></span><span> = <span><span><span>(<span class="type-var">'a</span>, unit, string, <a href="#type-attr">attr</a>)</span> <span class="xref-unresolved">Stdlib</span>.format4</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Special handling for string-value attributes so they can use format strings i.e. string interpolation.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-std_tag"><a href="#type-std_tag" class="anchor"></a><code><span><span class="keyword">type</span> std_tag</span><span> = <span><span><a href="#type-attr">attr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-node">node</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div><div class="spec-doc"><p>A 'standard' tag with attributes and children.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-void_tag"><a href="#type-void_tag" class="anchor"></a><code><span><span class="keyword">type</span> void_tag</span><span> = <span><span><a href="#type-attr">attr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div><div class="spec-doc"><p>A 'void element': <a href="https://developer.mozilla.org/en-US/docs/Glossary/Void_element">https://developer.mozilla.org/en-US/docs/Glossary/Void_element</a> with no children.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-text_tag"><a href="#type-text_tag" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a text_tag</span></span><span> = <span><span><a href="#type-attr">attr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, unit, string, <a href="#type-node">node</a>)</span> <span class="xref-unresolved">Stdlib</span>.format4</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Tags which can have attributes but can contain only text. The text can be formatted.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-attr"><a href="#val-attr" class="anchor"></a><code><span><span class="keyword">val</span> attr : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-attr">attr</a></span></code></div><div class="spec-doc"><p><code>attr name</code> is a new attribute which does not carry any payload. E.g.</p><pre class="language-ocaml"><code>  let required = attr &quot;required&quot;</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.1.0.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_attr"><a href="#val-string_attr" class="anchor"></a><code><span><span class="keyword">val</span> string_attr : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?raw</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">_</span> <a href="#type-string_attr">string_attr</a></span></span></code></div><div class="spec-doc"><p><code>string_attr name fmt</code> is a new string-valued attribute which allows formatting i.e. string interpolation of the value. Note, the <code>fmt</code> argument is required due to the value restriction.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">raw</span> <p>(default <code>false</code>) whether to inject the raw text or to escape it. Note that Dream does not support escaping inline JavaScript nor CSS, so neither does dream-html: <a href="https://github.com/aantron/dream/tree/master/example/7-template#security">https://github.com/aantron/dream/tree/master/example/7-template#security</a>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uri_attr"><a href="#val-uri_attr" class="anchor"></a><code><span><span class="keyword">val</span> uri_attr : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">_</span> <a href="#type-string_attr">string_attr</a></span></span></code></div><div class="spec-doc"><p>Convenience for attributes whose values should be URIs. Takes care of both URI-encoding and attribute escaping, as recommended in <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#common-mistake">https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#common-mistake</a>.</p><p>Examples</p><pre class="language-ocaml"><code>  a [href &quot;/blog?tags=iamsafe\&quot;&gt;&lt;/a&gt;&lt;script&gt;alert('Pwned')&lt;/script&gt;&quot;] [txt &quot;Tags: tag1 | tag2&quot;]
  ==&gt;
  &lt;a href=&quot;/blog?tags=iamsafe%22%3E%3C/a%3E%3Cscript%3Ealert('Pwned')%3C/script%3E&quot;&gt;Tags: tag1 | tag2&lt;/a&gt;

  a [href &quot;/foo?a=1&amp;b=2 3&amp;c=4&lt;5&amp;d=6&gt;5&quot;] [txt &quot;Test&quot;]
  ==&gt;
  &lt;a href=&quot;/foo?a=1&amp;amp;b=2%203&amp;amp;c=4%3C5&amp;amp;d=6%3E5&quot;&gt;Test&lt;/a&gt;</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bool_attr"><a href="#val-bool_attr" class="anchor"></a><code><span><span class="keyword">val</span> bool_attr : <span>string <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="#type-to_attr">to_attr</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-float_attr"><a href="#val-float_attr" class="anchor"></a><code><span><span class="keyword">val</span> float_attr : <span>string <span class="arrow">&#45;&gt;</span></span> <span>float <a href="#type-to_attr">to_attr</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int_attr"><a href="#val-int_attr" class="anchor"></a><code><span><span class="keyword">val</span> int_attr : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-to_attr">to_attr</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-std_tag"><a href="#val-std_tag" class="anchor"></a><code><span><span class="keyword">val</span> std_tag : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-std_tag">std_tag</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-void_tag"><a href="#val-void_tag" class="anchor"></a><code><span><span class="keyword">val</span> void_tag : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-void_tag">void_tag</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-text_tag"><a href="#val-text_tag" class="anchor"></a><code><span><span class="keyword">val</span> text_tag : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?raw</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">_</span> <a href="#type-text_tag">text_tag</a></span></span></code></div><div class="spec-doc"><p>Build a tag which can contain only text.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">raw</span> <p>(default <code>false</code>) whether to inject the raw text or to escape it. Note that Dream does not support escaping inline JavaScript nor CSS, so neither does dream-html: <a href="https://github.com/aantron/dream/tree/master/example/7-template#security">https://github.com/aantron/dream/tree/master/example/7-template#security</a>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uri_tag"><a href="#val-uri_tag" class="anchor"></a><code><span><span class="keyword">val</span> uri_tag : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">_</span> <a href="#type-text_tag">text_tag</a></span></span></code></div><div class="spec-doc"><p>Build a tag which can contain only a URI. The URI is escaped with the same rules as a <code>uri_attr</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.10.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-txt"><a href="#val-txt" class="anchor"></a><code><span><span class="keyword">val</span> txt : <span><span class="optlabel">?raw</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, unit, string, <a href="#type-node">node</a>)</span> <span class="xref-unresolved">Stdlib</span>.format4</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>A text node inside the DOM e.g. the 'hi' in <code>&lt;b&gt;hi&lt;/b&gt;</code>. Allows string interpolation using the same formatting features as <code>Printf.sprintf</code>:</p><pre class="language-ocaml"><code>  b [] [txt &quot;Hello, %s!&quot; name]</code></pre><p>Or without interpolation:</p><pre class="language-ocaml"><code>  b [] [txt &quot;Bold of you.&quot;]</code></pre><p>HTML-escapes the text value. You can use the <code>~raw</code> param to bypass escaping:</p><pre class="language-ocaml"><code>  let user_input = &quot;&lt;script&gt;alert('I like HTML injection')&lt;/script&gt;&quot; in
  txt ~raw:true &quot;%s&quot; user_input</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-comment"><a href="#val-comment" class="anchor"></a><code><span><span class="keyword">val</span> comment : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div><div class="spec-doc"><p>A comment that will be embedded in the rendered HTML, i.e. <code>&lt;!-- comment --&gt;</code>. The text is HTML-escaped.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-node">node</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div><div class="spec-doc"><p><code>concat node list</code> is the <code>list</code> of nodes joined together into a single node, with each element separated by <code>node</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.10.0</li></ul></div></div><h3 id="accessors-for-tags"><a href="#accessors-for-tags" class="anchor"></a>Accessors for tags</h3><div class="odoc-spec"><div class="spec value anchored" id="val-(+@)"><a href="#val-(+@)" class="anchor"></a><code><span><span class="keyword">val</span> (+@) : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attr">attr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div><div class="spec-doc"><p>Add an attribute to a tag.</p><pre class="language-ocaml"><code>  let toast msg = p [id &quot;toast&quot;] [txt &quot;%s&quot; msg]
  let toast_oob = toast &quot;ok.&quot; +@ Hx.swap_oob &quot;true&quot;</code></pre><p>If adding the <code>class</code> attribute to a tag which already has a <code>class</code> attribute, join together the values of the CSS classes:</p><pre class="language-ocaml"><code>  p [class_ &quot;foo&quot;] [] +@ class_ &quot;bar&quot;</code></pre><p>Result:</p><pre class="language-ocaml"><code>  &lt;p class=&quot;foo bar&quot;&gt;&lt;/p&gt;</code></pre><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the node is not a tag (i.e. if it is a text or comment node), or if it is a duplicate attribute other than <code>class</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.0.3.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(-@)"><a href="#val-(-@)" class="anchor"></a><code><span><span class="keyword">val</span> (-@) : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div><div class="spec-doc"><p>Remove an attribute from a tag.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the node is not a tag (i.e. if it is a text or comment node).</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.0.3.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(.@[])"><a href="#val-(.@[])" class="anchor"></a><code><span><span class="keyword">val</span> (.@[]) : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Get the value of an existing attribute.</p><pre class="language-ocaml"><code>  let toast = p [id &quot;toast&quot;] [txt &quot;OK.&quot;]
  let toast_id = toast.@[&quot;id&quot;]</code></pre><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the node is not a tag (i.e. if it is a text or comment node).</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if the tag does not have the given attribute.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.0.3.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_null"><a href="#val-is_null" class="anchor"></a><code><span><span class="keyword">val</span> is_null : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Get whether a node is null (empty) or not. Useful for conditional rendering of UIs when you are passed in a node and you don't know if it's empty or not.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.2.0.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_null_"><a href="#val-is_null_" class="anchor"></a><code><span><span class="keyword">val</span> is_null_ : <span><a href="#type-attr">attr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Get whether an attribute is null (empty) or not.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.2.0.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : 
  <span><span class="label">tag</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-attr">attr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">txt</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">comment</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold ~tag ~txt ~comment value node</code> is the value resulting from 'folding over' the <code>node</code> with an initial <code>value</code> and calling the following callbacks for each child in the node's tree:</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">tag</span> <p><code>name attrs value</code> is the value resulting from processing the given tag node's <code>name</code>, <code>attrs</code>, and the <code>value</code> calculated recursively from the tag's children.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">txt</span> <p><code>string value</code> is the value resulting from processing the given text node's <code>string</code> and the <code>value</code> calculated up until now.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">comment</span> <p><code>string value</code> is the value resulting from processing the given comment node's <code>string</code> and the <code>value</code> calculated up until now.</p></li></ul><p>Eg calculate a list of all the classes used by a node and its children:</p><pre class="language-ocaml"><code>  let tag _name attrs classes =
    match List.assoc_opt &quot;class&quot; attrs with
    | Some c -&gt; c :: classes
    | None -&gt; classes
  and txt_or_comment _string classes = classes in
  fold ~tag ~txt:txt_or_comment ~comment:txt_or_comment [] node</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.11.0</li></ul></div></div><h3 id="html"><a href="#html" class="anchor"></a>HTML</h3><div class="odoc-spec"><div class="spec module anchored" id="module-HTML"><a href="#module-HTML" class="anchor"></a><code><span><span class="keyword">module</span> <a href="HTML/index.html">HTML</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>All standard HTML attributes and tags. Some attributes and tags have the same name, e.g. <code>style</code>. To disambiguate them, attributes have a <code>_</code> (underscore) suffix.</p></div></div><h3 id="svg"><a href="#svg" class="anchor"></a>SVG</h3><div class="odoc-spec"><div class="spec module anchored" id="module-SVG"><a href="#module-SVG" class="anchor"></a><code><span><span class="keyword">module</span> <a href="SVG/index.html">SVG</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="mathml"><a href="#mathml" class="anchor"></a>MathML</h3><div class="odoc-spec"><div class="spec module anchored" id="module-MathML"><a href="#module-MathML" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MathML/index.html">MathML</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="aria"><a href="#aria" class="anchor"></a>ARIA</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Aria"><a href="#module-Aria" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Aria/index.html">Aria</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/">https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/</a></p></div></div><h3 id="rss-and-atom"><a href="#rss-and-atom" class="anchor"></a>RSS and Atom</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Atom"><a href="#module-Atom" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Atom/index.html">Atom</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-RSS"><a href="#module-RSS" class="anchor"></a><code><span><span class="keyword">module</span> <a href="RSS/index.html">RSS</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><a href="https://www.rssboard.org/rss-specification">RSS</a> support</p></div></div><h3 id="htmx"><a href="#htmx" class="anchor"></a>htmx</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Hx"><a href="#module-Hx" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Hx/index.html">Hx</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><a href="https://htmx.org/reference/">htmx</a> support</p></div></div></details></div><h3 id="dream-wrappers"><a href="#dream-wrappers" class="anchor"></a>Dream wrappers</h3><p>Convenience wrappers that use dream-html attributes and nodes instead of raw strings.</p><div class="odoc-spec"><div class="spec value anchored" id="val-respond"><a href="#val-respond" class="anchor"></a><code><span><span class="keyword">val</span> respond : 
  <span><span class="optlabel">?status</span>:<span>[&lt; <span class="xref-unresolved">Dream</span>.status ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?code</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?headers</span>:<span><span>(string * string)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Dream</span>.response <span class="xref-unresolved">Dream</span>.promise</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-redirect"><a href="#val-redirect" class="anchor"></a><code><span><span class="keyword">val</span> redirect : 
  <span><span class="optlabel">?status</span>:<span>[&lt; <span class="xref-unresolved">Dream</span>.redirection ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?code</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?headers</span>:<span><span>(string * string)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?flash</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Dream</span>.request <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-attr">attr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Dream</span>.response <span class="xref-unresolved">Dream</span>.promise</span></span></code></div><div class="spec-doc"><p><code>redirect ?status ?code ?headers ?flash req href</code> is the same as <code>Dream.redirect</code> but instead of taking a string location to redirect to, it takes an attribute (you'll usually want to use <code>href</code>). The reason for taking an attribute is that we can construct correct route paths in attributes without having to hard-code the entire path. Eg,</p><pre class="language-ocaml"><code>  let%path order = &quot;/orders/%s&quot;
  ...
  let order_id = ... in
  Dream_html.redirect req (path_attr href order order_id)</code></pre><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">flash</span> <p>convenience to add a flash message under the key <code>flash</code>. Internally just calls <code>Dream.add_flash_message</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.11.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-send"><a href="#val-send" class="anchor"></a><code><span><span class="keyword">val</span> send : 
  <span><span class="optlabel">?text_or_binary</span>:<span>[&lt; <span class="xref-unresolved">Dream</span>.text_or_binary ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?end_of_message</span>:<span>[&lt; <span class="xref-unresolved">Dream</span>.end_of_message ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Dream</span>.websocket <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="xref-unresolved">Dream</span>.promise</span></span></code></div><div class="spec-doc"><p>Type-safe wrapper for <code>Dream.send</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.2.0.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_body"><a href="#val-set_body" class="anchor"></a><code><span><span class="keyword">val</span> set_body : <span><span class="xref-unresolved">Dream</span>.response <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Type-safe wrapper for <code>Dream.set_body</code>. Sets the body to the given <code>node</code> and sets the <code>Content-Type</code> header to <code>text/html</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : <span><span class="xref-unresolved">Dream</span>.stream <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Dream</span>.promise</span></span></code></div><div class="spec-doc"><p>Type-safe wrapper for <code>Dream.write</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-csrf_tag"><a href="#val-csrf_tag" class="anchor"></a><code><span><span class="keyword">val</span> csrf_tag : <span><span class="xref-unresolved">Dream</span>.request <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div><div class="spec-doc"><p>Convenience to add a CSRF token generated by Dream into your form. Type-safe equivalent of <code>Dream.csrf_tag</code>.</p><pre class="language-ocaml"><code>  form
    [action &quot;/foo&quot;]
    [csrf_tag req; input [name &quot;bar&quot;]; input [type_ &quot;submit&quot;]]</code></pre></div></div><h3 id="conditional-requests"><a href="#conditional-requests" class="anchor"></a>Conditional requests</h3><p>Helpers for managing HTTP conditional requests. Note that the ETag values derived from the <code>key</code> parameters are not using cryptographically secure hashing. For example, for a key <code>foo</code>, we currently derive an ETag of <code>&quot;acbd18db4cc2f85cedef654fccc4a4d8&quot;</code>. It is your responsibility to provide a key that uniquely identifies the version of the resource and changes when the resource is updated.</p><p>Eg, the last modified date of a file is a reasonable key for the contents of the file because it is guaranteed to change when the file is changed. Of course, you may prefer other even better ways to generate keys for resources.</p><p>See <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/ETag#examples">MDN documentation</a> for examples of idiomatic usage of these headers.</p><div class="odoc-spec"><div class="spec value anchored" id="val-if_none_match"><a href="#val-if_none_match" class="anchor"></a><code><span><span class="keyword">val</span> if_none_match : 
  <span><span class="xref-unresolved">Dream</span>.request <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key</span>:<span>[&lt; `None <span><span>| `Strong</span> of string</span> <span><span>| `Weak</span> of string</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Dream</span>.response <span class="xref-unresolved">Dream</span>.promise</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Dream</span>.response <span class="xref-unresolved">Dream</span>.promise</span></span></code></div><div class="spec-doc"><p><code>if_none_match req ~key refresh</code> checks the <code>If-None-Match</code> header of <code>req</code> to see if it contains an ETag derived from the <code>key</code>. If so, it responds with <code>304 Not Modified</code> and an empty body. Otherwise, it re-fetches the resource corresponding to <code>key</code> using <code>refresh ()</code>, and sets the ETag in the response header.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">key</span> <p>(eg a timestamp) together with the strength of its validator, is used to derive an ETag. If <code>`None</code>, the server does not know about the resource and responds with a <code>404 Not Found</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.11.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-if_match"><a href="#val-if_match" class="anchor"></a><code><span><span class="keyword">val</span> if_match : 
  <span><span class="xref-unresolved">Dream</span>.request <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key</span>:<span>[&lt; `None <span><span>| `Strong</span> of string</span> <span><span>| `Weak</span> of string</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Dream</span>.response <span class="xref-unresolved">Dream</span>.promise</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Dream</span>.response <span class="xref-unresolved">Dream</span>.promise</span></span></code></div><div class="spec-doc"><p><code>if_match req ~key save</code> checks if the <code>If-Match</code> header of <code>req</code> matches the ETag derived from the <code>key</code>. If so, it calls <code>save ()</code> and returns the response. Otherwise, it responds with an error <code>412 Precondition Failed</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">key</span> <p>(eg a timestamp) together with the strength of its validator, is used to derive an ETag. If <code>`None</code>, the server does not know about the resource and thus allows it to be updated with <code>save ()</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.11.0</li></ul></div></div><h3 id="type-safe-routing"><a href="#type-safe-routing" class="anchor"></a>Type-safe routing</h3><p>Bidirectional paths with type-safe path segment parsing and printing using OCaml's built-in format strings, and fully plug-and-play compatible with Dream routes.</p><div class="odoc-spec"><div class="spec type anchored" id="type-path"><a href="#type-path" class="anchor"></a><code><span><span class="keyword">type</span> <span>(_, _) path</span></span></code></div><div class="spec-doc"><p>A path that can be used for routing and can also be printed as an attribute value.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-route"><a href="#type-route" class="anchor"></a><code><span><span class="keyword">type</span> <span>('r, 'p) route</span></span><span> = <span><span><span>(<span class="type-var">'r</span>, <span class="type-var">'p</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="xref-unresolved">Dream</span>.request <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Dream</span>.route</span></code></div><div class="spec-doc"><p>Wrapper for a Dream route that represents the ability to parse path parameters and pass them to the handler function with the correct types.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-path"><a href="#val-path" class="anchor"></a><code><span><span class="keyword">val</span> path : 
  <span><span><span>(<span class="type-var">'r</span>, unit, <span><span class="xref-unresolved">Dream</span>.response <span class="xref-unresolved">Dream</span>.promise</span>)</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'p</span>, unit, string, <a href="#type-attr">attr</a>)</span> <span class="xref-unresolved">Stdlib</span>.format4</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'r</span>, <span class="type-var">'p</span>)</span> <a href="#type-path">path</a></span></span></code></div><div class="spec-doc"><p><code>path request_fmt attr_fmt</code> is a router path. The <code>dream-html.ppx</code> provides a more convenient way.</p><p>Without PPX: <code>let order = path &quot;/orders/%s&quot; &quot;/orders/%s&quot;</code></p><p>With PPX: <code>let%path order = &quot;/orders/%s&quot;</code></p><p>Refer to <a href="../Ppx/index.html" title="Ppx">the PPX documentation</a> for instructions on using it.</p><p>⚠️ Due to the way Dream's router works, all parameter captures happen between <code>/</code> characters and the end of the path (or the <code>?</code> character, whichever comes first). Eg, <code>/foo/%s/bar/%d</code> is valid, but <code>/foo/%s.%s</code> (note the dot character) is not a valid capture.</p><p>⚠️ If a route is matched but the data type does not match, a <code>400 Bad Request</code> response will be returned. The following type conversion specs are supported:</p><p><code>%s</code> capture a <code>string</code> and pass it to the handler</p><p><code>%*s</code> capture the rest of the path and pass the captured length and string to the handler</p><p><code>%c</code> capture a <code>char</code></p><p><code>%d</code> or <code>%i</code> capture an <code>int</code></p><p><code>%x</code> capture a hexadecimal <code>int</code></p><p><code>%X</code> capture an uppercase hexadecimal <code>int</code></p><p><code>%o</code> capture an octal <code>int</code></p><p><code>%ld</code> capture an <code>int32</code></p><p><code>%Ld</code> capture an <code>int64</code></p><p><code>%f</code> capture a <code>float</code></p><p><code>%B</code> capture a <code>bool</code></p><p>⚠️ We are actually using Dream's built-in router, not our own, and Dream's router doesn't distinguish between parameter types. So, to Dream both <code>/%s</code> and <code>/%d</code> are the same path. It will route the request to whichever happens to be first in the route list, and that one will succeed or fail depending on its type and the request target.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-path_attr"><a href="#val-path_attr" class="anchor"></a><code><span><span class="keyword">val</span> path_attr : <span><span><span class="type-var">'p</span> <a href="#type-string_attr">string_attr</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">_</span>, <span class="type-var">'p</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'p</span></span></code></div><div class="spec-doc"><p><code>path_attr attr path</code> is an HTML attribute with the path parameters filled in from the given values. Eg,</p><pre class="language-ocaml"><code>  let%path order = &quot;/orders/%s&quot;

  open Dream_html
  open HTML

  a [path_attr href order &quot;yzxyzc&quot;] [txt &quot;My Order&quot;]</code></pre><p>Renders: <code>&lt;a href=&quot;/orders/yzxyzc&quot;&gt;My Order&lt;/a&gt;</code></p><p>Use this instead of hard-coding your route URLs throughout your app, to make it easy to refactor routes with minimal effort.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_path"><a href="#val-pp_path" class="anchor"></a><code><span><span class="keyword">val</span> pp_path : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-path">path</a></span> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div><div class="spec-doc"><p><code>pp_path</code> is a pretty-printer for path values. For a path like <code>path &quot;/foo&quot; &quot;/foo&quot;</code>, it will print out <code>/foo</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-route">route</a></span></span></code></div><div class="spec-doc"><p>Type-safe wrappers for <code>Dream.get</code> and so on. Using the PPX, eg:</p><pre class="language-ocaml"><code>  let%path order = &quot;/orders/%s&quot;

  let get_order = get order (fun request order_id -&gt;
    ...
    a [path_attr href order order_id] [txt &quot;Your order&quot;]
    ...
  )</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-post"><a href="#val-post" class="anchor"></a><code><span><span class="keyword">val</span> post : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-route">route</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-put"><a href="#val-put" class="anchor"></a><code><span><span class="keyword">val</span> put : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-route">route</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-delete"><a href="#val-delete" class="anchor"></a><code><span><span class="keyword">val</span> delete : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-route">route</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-head"><a href="#val-head" class="anchor"></a><code><span><span class="keyword">val</span> head : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-route">route</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-connect"><a href="#val-connect" class="anchor"></a><code><span><span class="keyword">val</span> connect : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-route">route</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-options"><a href="#val-options" class="anchor"></a><code><span><span class="keyword">val</span> options : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-route">route</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trace"><a href="#val-trace" class="anchor"></a><code><span><span class="keyword">val</span> trace : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-route">route</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-patch"><a href="#val-patch" class="anchor"></a><code><span><span class="keyword">val</span> patch : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-route">route</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-any"><a href="#val-any" class="anchor"></a><code><span><span class="keyword">val</span> any : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-route">route</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-use"><a href="#val-use" class="anchor"></a><code><span><span class="keyword">val</span> use : <span><span><span class="xref-unresolved">Dream</span>.middleware list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Dream</span>.route list</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Dream</span>.route</span></code></div><div class="spec-doc"><p><code>use middlewares routes</code> is a route that is composed of all the given <code>routes</code> with the <code>middlewares</code> attached to them.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-static_asset"><a href="#val-static_asset" class="anchor"></a><code><span><span class="keyword">val</span> static_asset : <span><span><span>(<span><span class="xref-unresolved">Dream</span>.response <span class="xref-unresolved">Dream</span>.promise</span>, <span class="type-var">_</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Dream</span>.route</span></code></div><div class="spec-doc"><p><code>static_asset path</code> is a route that handles serving the static file at the <code>path</code>. Importantly, it sets an immutable cache header which remains valid for a year.</p><p>⚠️ Be sure that the resource has a unique identifier because it will be cached immutably. The <code>dreamwork</code> CLI tool automates this for you. See <a href="#dreamwork" title="dreamwork">Dreamwork</a>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.2</li></ul></div></div><h3 id="dreamwork"><a href="#dreamwork" class="anchor"></a>Dreamwork</h3><p>TL;DR:</p><ol><li>Run <code>dreamwork setup</code></li><li>Populate the <code>static/assets/</code> subdirectory with files</li><li>Run <code>dune build</code></li><li>Add <code>Static.routes</code> to the app's main Dream router</li><li>Use eg <code>img [path_attr src Static.Assets.icon_png]</code> which will render with a revision hash based on the file contents, calculated at build time</li></ol><p><code>dreamwork</code> is a CLI tool that helps set up and manage static file paths and routes with proper content-based version hashes. The static files will live inside a dune component called <code>static</code> and in the <code>static/assets</code> subdirectory. Suppose you have the following directory tree:</p><pre>static/
  dune
  assets/
    css/
      app.css
    js/
      app.js</pre><p>The <code>dune</code> file defines a <code>library</code> component that will make the following module available:</p><pre class="language-ocaml"><code>  module Static : sig
    val routes : Dream.route
    (** This route will serve all of the following paths. *)

    module Assets : sig
      module Css : sig
        val app_css : (Dream.response Dream.promise, attr) path
      end

      module Js : sig
        val app_js : (Dream.response Dream.promise, attr) path
      end
    end
  end</code></pre><p>So, you can just stick <code>Static.routes</code> in your router and it will correctly serve the files from the filesystem with an immutable cache of 1 year; and you can use <code>Static.Assets.Css.app_css</code> and so on in your dream-html markup code and it will correctly render with a <code>?rev=...</code> query parameter that uniquely identifies this revision of the file with a content-based hash for cache-busting purposes:</p><pre class="language-ocaml"><code>  link [rel &quot;stylesheet&quot;; path_attr href Static.Assets.Css.app_css
  (*
  &lt;link
    rel=&quot;stylesheet&quot;
    href=&quot;/static/assets/css/app.css?rev=17fb8161afc85df86156ea1f3744c8a2&quot;
  &gt;
  *)</code></pre><pre class="language-ocaml"><code>  script [path_attr src Static.Assets.Js.app_js] &quot;&quot;
  (*
  &lt;script src=&quot;/static/assets/js/app.js?rev=677645e5ac37d683c5039a85c41c339f&quot;&gt;
  &lt;/script&gt;
  *)</code></pre><p>You control the directory subtree under <code>assets</code>; the <code>dreamwork</code> CLI just helps you define the <code>dune</code> component that generates the above module structure. The module structure mirrors the directory tree structure.</p><p>The entry point to <code>dreamwork</code> is the <code>dreamwork setup</code> command, which creates <code>static/</code>, <code>assets/</code>, and <code>dune</code>. In the <code>dune</code> file it defines a code generation rule which uses the <code>dreamwork static</code> command to generate the OCaml code.</p><p>So, you just need to run <code>dreamwork setup</code> to initialize the directory structure and code generation. After that, you can add and remove any files inside <code>assets/</code> as you want and on the next dune build the <code>Static</code> module structure will be updated accordingly.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.9.2</li></ul><h3 id="live-reload-support"><a href="#live-reload-support" class="anchor"></a>Live reload support</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Livereload"><a href="#module-Livereload" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Livereload/index.html">Livereload</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Live reload script injection and handling. Adapted from <code>Dream.livereload</code> middleware. This version is not a middleware so it's not as plug-and-play as that, but on the other hand it's much simpler to implement because it uses type-safe dream-html nodes rather than parsing and printing raw HTML. See below for the 3-step process to use it.</p></div></div></div></body></html>
